// Advanced Part 3 about a really dumb investment strategy
//==========================================================

object CW6c {


//two test portfolios

val blchip_portfolio = List("GOOG", "AAPL", "MSFT", "IBM", "FB", "AMZN", "BIDU")
val rstate_portfolio = List("PLD", "PSA", "AMT", "AIV", "AVB", "BXP", "CCI", 
                            "DLR", "EQIX", "EQR", "ESS", "EXR", "FRT", "GGP", "HCP") 
						
							
// (1.a) The function below takes a stock symbol and a year as arguments.
//       It should read the corresponding CSV-file and read the January 
//       data from the given year. The data should be collected in a list of
//       strings for each line in the CSV-file.

import io.Source
import scala.util._

	
def get_csv_file(file: String) : List[String] = {

	val fileAsString = Try(Source.fromFile(file).mkString).getOrElse { println(s"  Problem with: $file"); ""}
	val fileLinesList = fileAsString.split("\n").toList
	
	val newList = process_file(fileLinesList)
	
	//fileLinesList
	
	newList
	
}			
							
def process_file(lines: List[String]) : List[String] = {

	if (Try(lines(0).split("-")(0).toLong).isFailure)	{	// Does the first line contain numbers or not? remove first line if it does not.
		val newList = lines.drop(1) 
				
		newList

	}
	
	else { 
		val newList = lines 
		
		newList
		
	}

}


def get_january_data(symbol: String, year: Int) : List[String] = {

	val newList : List[String] = get_csv_file(symbol)
	
	val listOfNewStrings = newList.filter(_.split("-")(0) == year.toString)
	
	listOfNewStrings

}


// (1.b) From the output of the get_january_data function, the next function 
//       should extract the first line (if it exists) and the corresponding
//       first trading price in that year as Option[Double]. If no line is 
//       generated by get_january_data then the result is None


def get_first_price(symbol: String, year: Int) : Option[Double] = {
	
	val listOfJustYears = get_january_data(symbol, year)
	
	val priceOnly = Try(listOfJustYears.head.split(",")(1).toDouble).getOrElse(None)
	
	if (priceOnly == None) None // because it's None so shouldn't matter

	else Some(priceOnly.asInstanceOf[Double])
	
}


// (1.c) Complete the function below that obtains all first prices
//       for the stock symbols from a portfolio (list of strings) and 
//       for the given range of years. The inner lists are for the
//       stock symbols and the outer list for the years.


def get_prices(portfolio: List[String], years: Range) : List[List[Option[Double]]] = {
	
	val outerLists = for (year <- years) yield {
		for (symbol <- portfolio) yield {
			val newSymbol = symbol + ".csv"	// SMALL HACK TO WORK WITHOUT INITIAL .csv

			get_first_price(newSymbol, year) 
		}	
	}
	
	val outerListsList = outerLists.toList

	outerListsList
	
}


// (2) The first function below calculates the change factor (delta) between
//     a price in year n and a price in year n + 1. The second function calculates
//     all change factors for all prices (from a portfolio). The input to this
//     function are the nested lists created by get_prices above.

def get_delta(price_old: Option[Double], price_new: Option[Double]) : Option[Double] = {	
	
	val delta = Try(((price_new.get) - (price_old.get)) / price_old.get).getOrElse { None }	
	
	if (delta == None) None // because it's None so shouldn't matter

	else Some(delta.asInstanceOf[Double]) 

}


def get_deltas(data: List[List[Option[Double]]]) :  List[List[Option[Double]]] = {

	//what we already have is the result of get_prices (outerListsList)
	
	//send each thing in outerListsList.head and outerListsList.tail to get_delta
	
	val dataListList = data
	
		val changeFactors = for (firstListIndex <- (0 to dataListList.size-1-1).toList) yield {
		
			for (priceIndex <- (0 to dataListList(firstListIndex).size-1).toList) yield {
				//pass respective items in first list + also in the following list
				get_delta(dataListList(firstListIndex)(priceIndex), dataListList(firstListIndex+1)(priceIndex))
			}
		}	
	
	changeFactors

}


// (3) function that given change factors, a starting balance and a year
//     calculates the yearly yield, i.e. new balance, according to our dump investment 
//     strategy. Another function calculates given the same data calculates the
//     compound yield up to a given year. Finally a function combines all 
//     calculations by taking a portfolio, a range of years and a start balance
//     as arguments.


def yearly_yield(data: List[List[Option[Double]]], balance: Long, year: Int) : Long = {
		
	if (data(year).size == 0) {
		println("BALANCE IS UNCHANGED!!")
		balance
	}
		
	//Otherwise, 
	else {
		//invest in each existing company an equal amount of our balance. 
		//Using the change factors computed under Task 2, calculate the new balance.
		
		val noOfExistingCompanies = data(year).size		
		val payToEachCompany = balance / noOfExistingCompanies		
		
		val multiplications = for (factor <- data(year)) yield {
		
			if (factor == None) {
			0	
			} // because it's None so shouldn't matter

			else factor.get * payToEachCompany 
		
		}
			
		val receive = multiplications.sum
		
		//convert answer to a long
		val newBalance = (balance + receive).toLong
	
		//$50 * -0.03573992567129673 + $50 * 0.5399749442411563 = $25.21175092849298
	
		newBalance
	}

}

//def compound_yield(data: List[List[Option[Double]]], balance: Long, year: Int) : Long = {

def recurs(portfolio: List[String], years: Range, balance: Long, year: Int) : Long = {

	//needs to send result of yearly_yield for the year, back into yearly_yield

	if (year < years.size-1) { // THIS -1 IS OK FOR YEAR STARTING AT ZEROTH
		
		val prices = get_prices(portfolio, years)
		
		val data = get_deltas(prices)	
		
		//(was previously written as val balanceIn = yearly_yield(get_deltas(get_prices(portfolio, years)), balance, year))
		val balanceIn = yearly_yield(data, balance, year)
		println("New balance: " + balanceIn)
		
		//call itself again!
		val newYear = year + 1
		recurs(portfolio, years, balanceIn, newYear)
	}
	else {

		balance
	}

}


def investment(portfolio: List[String], years: Range, start_balance: Long) : Long = {

	//calculates the overall balance for a range of years
	//where each year the yearly profit is compounded to the new balances and then re-invested into our portfolio.

	//println("Initial balance: " + start_balance)
	
	val investment = recurs(portfolio: List[String], years, start_balance, 0)

	//println("Final investment result: " + investment)
	
	investment
	
}
	
//test cases for the two portfolios given above

//investment(rstate_portfolio, 1978 to 2017, 100)
//investment(blchip_portfolio, 1978 to 2017, 100)

}